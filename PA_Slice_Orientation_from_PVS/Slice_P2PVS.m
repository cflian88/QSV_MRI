function Slice_P2PVS(fo,fc,prefix,center,f_T2,do_debug)
% fc: the file containing the clustered PVS masks
% fo: the file containing the orientions of PVS; generated by PVS_orient
% prefix: output file to save the results
% tilt_A2S: head tilt from axial to sagittal
% center: center of the PC slice
% initial tilt for A2C0; the final A2C will be optimized 
if ~exist('do_debug','var')
    do_debug=true;
end

orient=get_orient(fc);
load(fc,'c','ind','path','voxsize','nvox_path');
if ~exist('nvox_path','var') %old files
 nvox_path=cellLen(path);
end

load(fo,'norm','norm_seg');
%%

sz=size(c);
thr=10;

box=16;

%center=ijk2xyz(ijk,orient);
ijk=xyz2ijk(center,orient);

ctmp=c*0;
ctmp(ijk(1)-box/2:ijk(1)+box/2-1,ijk(2)-box/2:ijk(2)+box/2-1,ijk(3)-box/2:ijk(3)+box/2-1)=...
    c(ijk(1)-box/2:ijk(1)+box/2-1,ijk(2)-box/2:ijk(2)+box/2-1,ijk(3)-box/2:ijk(3)+box/2-1);

id=unique(c(ctmp>0));
norm_ave=mean(norm(:,id),2);

th=(2:2:10);
th_all=[];
ph_all=[];

d2r=pi/180;
count=0;
for i=1:length(th)
    dth=th(2)-th(1);
    cosphi=(cos(dth*d2r)-1)/sin(th(i)*d2r)/sin(th(i)*d2r)+1;
    dphi=acos(cosphi)*180/pi;
    phi=0:dphi:360;
    
    for j=1:length(phi)    
       norm=get_norm(norm_ave,th(i),phi(j));   
       count=count+1;
       [ag{count},ipvs{count}]=find_intercept(ind,nvox_path,norm_seg,center,norm,sz,orient);               
     
       nperp(count)=sum(ag{count}<thr);
       th_all(count)=th(i);
       ph_all(count)=phi(j);
    end
      
end

 

[nperp_max,imax]=max(nperp);
fprintf('number of perp PVS = %d\n',nperp_max);
norm = get_norm(norm_ave,th_all(imax),ph_all(imax));
Norm2SliceOrient(norm);

%% for debug
if do_debug
T2=do_SliceT2_T2C_parietal(center,norm,f_T2);  %debug
o_ref=get_o_ref(norm,center);    
m=find_intercept2(ind,nvox_path,o_ref,orient,sz);
m_perp=remove_tilt_pvs(m,ipvs{imax}(ag{imax}<thr));
save(prefix,'nperp','ag','ipvs','T2','m','m_perp','ijk','center','norm','nperp_max','imax');
else
save(prefix,'nperp','ag','ipvs','ijk','center','norm','nperp_max','imax'); 
end

    function res = get_norm(norm_ave,th,phi)
        [th0,phi0]=unitVec2thetaPhi(norm_ave);
        m=transform_matrix_rotation(th0,phi0);
        
        vec=thetaPhi2unitVec(th,phi);
        
        res=m*vec';
        
        
function c2=find_intercept2(ind,nvox_path,o_ref,o_ind,sz)
% norm: 1*3
% norm_seg: 3*n cells
% the coordinate system assumes rotmat=eye(3) and pos =[0,0,0] for the T2
% images;


sz_interp=[512,512,1];
c2=zeros(sz_interp);


for i=1:length(ind)
    
    sub=ind2subb(sz,ind{i}(1:nvox_path(i)));
    xyz=ijk2xyz(sub,o_ind);
    res=dist2plane(xyz,o_ref.center,o_ref.rotmat(:,3));
    
    iint=find(sign(res(1:end-1)).*sign(res(2:end))<=0);
    if length(iint)>1 || isempty(iint)
        continue;
    end
    
    if abs(res(iint))<abs(res(iint+1))
        %an(count)=angle_bw_2vec(norm_seg{i}(:,iint)',norm);      
        iint2=iint;
    else
        %an(count)=angle_bw_2vec(norm_seg{i}(:,iint+1)',norm);      
        iint2=iint+1;
    end
    ijk=xyz2ijk(xyz(iint2,:),o_ref);
        
    
    c2(ijk(1),ijk(2))=i;
 %   T2b(ijk(1),c2(ijk(2)))=T2(sub(iint2,1),sub(iint2,2),sub(iint2,3));
        
end

function m=remove_tilt_pvs(m,ipvs_perp)

ipvs=unique(m(:));
ipvs(ipvs==0)=[];
ipvs(isnan(ipvs))=[];
thr=10;



ipvs_tilt=setdiff(ipvs,ipvs_perp);
for i=ipvs_tilt'
  m(m==i)=0;
end

tmp=setdiff(ipvs_perp,ipvs);
if ~isempty(tmp)
    error('this should not happen');
end

%% reslice method

function [an,ipvs,m]=find_intercept(ind,nvox_path,norm_seg,center,norm,sz,orient)
% norm: 1*3
% norm_seg: 3*n cells

an=[];
ipvs=[]; % the indices of the PVS that intercept the plane.
count=0;
m=zeros(sz);
for i=1:length(ind)    
    sub=ind2subb(sz,ind{i}(1:nvox_path(i)));
    
    xyz=ijk2xyz(sub,orient);
    res=dist2plane(xyz,center,norm);
    
    
    iint=find(sign(res(1:end-1)).*sign(res(2:end))<=0);
    if length(iint)>1 || isempty(iint)
        continue;
    end
    
    count=count+1;
    if abs(res(iint))<abs(res(iint+1))
        iint2=iint;
    else
        iint2=iint+1;      
    end
     an(count)=angle_bw_2vec(norm_seg{i}(:,iint2)',norm);      
    
    ipvs(count)=i;
    
    m(ind{i}(iint2))=i;
    
end


function T2b=do_SliceT2_T2C_parietal(center,norm,f_T2) % for debug 


    T2=ri(f_T2);
    o_T2=get_orient_from_nii(f_T2);
     o_ref=get_o_ref(norm,center);
     
    
    
    T2b=reslice_with_orient([512,512,1],o_ref,o_T2,T2);
    

    function o_ref=get_o_ref(norm,center)
         rotmat=norm2rotmat(norm);
    
    o_ref.voxsize=[0.4,0.4,1];
    o_ref.center=center;
    
    o_ref.pos=center2pos(o_ref.voxsize,rotmat,[512,512,1],center);
    o_ref.rotmat=rotmat;
    o_ref.oreint='LPI';

function res=norm2rotmat(norm)

c=norm(:);
a=[1,0,0]';
a=a-c*sum(c.*a);
a=a/sos(a,1);
b=cross(c,a,1);
res=[a,b,c];



function res=dist2plane(v,center,norm)
% v=n*3;
% center: 1*3;
% norm=1*3

res=sum((v-center(:)').*norm(:)',2);






